<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Throught the Nightmares - Ghost Flask Demo</title>
    <link rel="shortcut icon" href="GhostFlask/TemplateData/favicon.ico">
    <link rel="stylesheet" href="GhostFlask/TemplateData/style.css">
    <script src="GhostFlask/TemplateData/UnityProgress.js"></script>  
    <script src="GhostFlask/Build/UnityLoader.js"></script>
    <script>
      var gameInstance = UnityLoader.instantiate("gameContainer", "GhostFlask/Build/GhostSandman.json", {onProgress: UnityProgress});
    </script>
  </head>
  <body bgcolor = '1d1d1d'>

  	<h1>Ghost Flask Demo</h1>
  	<p class="center">In the <a href="https://www.facebook.com/SandmanGame" target="_blank">Throught the Nightmares</a> game, it used for showing why player can't place the flask.</p>

<video width="600" autoplay loop controls>
  <source src="GhostFlask/video.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>

<br>
    <div class="webgl-content">
      <div id="gameContainer" style="width: 600px; height: 600px"></div>
      <div class="footer">
        <div class="fullscreen" onclick="gameInstance.SetFullscreen(1)"></div>
      </div>
    </div>
    <h2>Shader code:</h2>
    <textarea rows="100" readonly>
Shader "Sandman/GhostFlaskWithSandman"
{
	Properties
	{
		_MainTex("Albedo (RGB)", 2D) = "white" {}
		_Animation("Animation", Range(0, 1)) = 0.0
		_AlphaAddition("Alpha Addition", Range(0, 1)) = 0.0
		_FogSpeed("Fog Speed", Range(0, 1)) = 0.0

		_Multiplier("Multiplier", float) = 1
		_NormalColor("Normal Color", Color) = (1,1,1,1)
		_BlockedColor("Blocked Color", Color) = (1,1,1,1)
	}
	SubShader
	{
		Tags { "Queue"="Transparent" "RenderType"="Transparent" }
		Blend SrcAlpha OneMinusSrcAlpha
		ZWrite off
        
		Pass
		{
		//bg
			ZTest Greater

			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			struct v2f
			{
				float4 vertex : SV_POSITION;
				float3 normal : NORMAL;
				float3 viewDir : TEXCOORD1;
				float2 uv : TEXCOORD0;
			};

			sampler2D _MainTex;
			float4 _BlockedColor;
			float _AlphaAddition;
			float _Multiplier;
			float _Animation;
			float _FogSpeed;
			float4 _MainTex_ST;

			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.viewDir = normalize(WorldSpaceViewDir(v.vertex));
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				float alpha = (1 - dot(i.normal, i.viewDir)) * _Multiplier;
				float alphaFactor = (tex2D(_MainTex, i.uv + _Time.gg * _FogSpeed).b + _AlphaAddition) * _Animation;
				_BlockedColor.a = alphaFactor * alpha;
				return _BlockedColor;
			}
			ENDCG
		}

		Pass
		{
		//normal
			ZTest LEqual

			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			
			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};


			struct v2f
			{
				float4 vertex : SV_POSITION;
				float3 normal : NORMAL;
				float3 viewDir : TEXCOORD1;
				float2 uv : TEXCOORD0;
			};
			
			sampler2D _MainTex;
			float4 _NormalColor;
			float _Animation;
			float _AlphaAddition;
			float _Multiplier;	
			float _FogSpeed;
			float4 _MainTex_ST;


			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.viewDir = normalize(WorldSpaceViewDir(v.vertex));
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				float alpha = (1 - dot(i.normal, i.viewDir)) * _Multiplier;
				float alphaFactor = (tex2D(_MainTex, i.uv + _Time.gg * _FogSpeed).b + _AlphaAddition) * _Animation;
				_NormalColor.a = alpha * alphaFactor;
				return _NormalColor;
			}
						
			ENDCG
		}
	}
}

	</textarea>


	<h2>Explanation</h2>
	<p>
It is a simple two-pass shader. <br>
First pass (ZTest Greater) renders pixel, if the distance between the object and camera in this pixel’s coordinate is greater than ZBuffer value - meaning our object is being overlapped by something.<br>
<br>
Second pass (ZTest LEqual) renders pixel if the distance is less or equal to ZBuffer value. Same as a regular render.<br>
<br>
Vertex shaders are identical:<br>
<textarea rows="9" readonly>
v2f vert (appdata v)
{
	v2f o;
	o.vertex = UnityObjectToClipPos(v.vertex);
	o.normal = UnityObjectToWorldNormal(v.normal);
	o.viewDir = normalize(WorldSpaceViewDir(v.vertex));
	o.uv = TRANSFORM_TEX(v.uv, _MainTex);
	return o;
}</textarea>
<br>
We transform coordinates and normals, calculate direction from a point to camera and transform UV-coordinates, to get tiling working.<br>
<br>
Fragment shaders are identical as well, with one exception - the first pass uses color from property _BlockedColor (we have red in the game), the second uses _NormalColor (pale yellow). We will use second as an example.<br>
<br>
First line:<br>
<textarea rows="1" readonly>
float alpha = 1 - dot(i.normal, i.viewDir);
</textarea>
<br>
The scalar product between the camera direction vector and the normal shows similarity between the angles of these vectors. <br>
“1” means they are unidirectional, “0” stands for 90º angle, “-1” - if they are opposite (but the last case is not going to happen, because this geometry is cut off with the rule). Subtract this value from one to get the opposite effect. Subsequently, this will be our alpha - the edges of the object, turned away from the camera, will be perfectly visible, and the polygons, facing the camera directly, will not be visible. <br>
It makes a great ghost effect - the classic "ghost shader" from many games.<br>
<br>
Second line:<br>
<textarea rows="2" readonly>
float alphaFactor = tex2D(_MainTex, i.uv + _Time.gg * _FogSpeed).b + _AlphaAddition;
</textarea>
<br>
Let us multiply the results and write the value into the output color alpha channel. Multiply all of this by _Multiplier - to control the transparency. <br>
In the end, multiply by _Animation to set the appear/disappear animation, changing this value from zero to one and back smoothly.<br>
<br>
Last line is self-explanatory:<br>
<textarea rows="1" readonly>
return _NormalColor;
</textarea>
<br>
Basically, that’s it. If you have any questions, please contact us by the links below or write to <a href="mailto:kovnir.alik@gmail.com?Subject=Ghost%20Flask%20Shader">email</a>!
	</p>
	<p class="center">Our pages in social networks:<br>
		<a href="https://www.facebook.com/SandmanGame/" target="_blank">Facebook</a><br>
		<a href="https://vk.com/sandmangame" target="_blank">Vk</a>
	</p>
  </body>
</html>